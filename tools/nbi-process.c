/* This file is part of NBI, a library for Nystrom Boundary Integral solvers
 *
 * Copyright (C) 2021 Michael Carley
 *
 * NBI is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version. NBI is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with NBI.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /*HAVE_CONFIG_H*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>

#include <glib.h>

#include <nbi.h>

#include <wbfmm.h>
#include <sqt.h>

#include <blaswrap.h>

#include "nbi-private.h"

GTimer *timer ;
gchar *progname ;

/**
 * @page nbiprocess Processing NBI output
 *
 * @c nbi-process is used to process results from an NBI calculation,
 * for visualization or further analysis. It takes an NBI surface file
 * and, optionally, a surface data file and generates a .msh file
 * which can be read by GMSH for visualization. 
 *
 * @verbatim
 nbi-process -h
 @endverbatim
 *
 * gives a current list of command line options. The most important
 * options are:
 * - @c -g the name of the geometry file to be read (this is required);
 * - @c -d the name of the data file to be read;
 * 
 * If no data file is supplied, the mesh is output with no associated
 * data. This is useful for visualizing a surface to check it looks
 * correct before running a calculation.
 *
 * The output mesh is made up of planar triangles generated by
 * recursive subdivision of the surface patches on the input. The
 * recursion level is set using the @c -r option, and defaults to 2. 
 *
 * The numbering of the output mesh nodes and elements starts from 1
 * by default. If you want to display multiple meshes at once, such as
 * the surface in the problem and a radiated field, use the @c -p and
 * @c -e options to set the first indices on a mesh so that its
 * numbering does not conflict with other meshes'. @c nbi-process
 * outputs the final values of the indices, incremented by one so that
 * they can be used as the initial values on the next mesh to be generated. 
 *
 */

static void print_help_text(FILE *f, gint offt, gint field, gint offp,
			    gint dmax)

{
  fprintf(f, 
	  "%s: process NBI surfaces and data sets\n\n"
	  "Usage:\n\n"
	  "  %s <options>\n\n",
	  progname, progname) ;
  
  fprintf(f,
	  "Output is a mesh and data file which can be viewed with GMSH.\n"
	  "On exit, total number of mesh points and elements is written to\n"
	  "stderr, for use in the -p and -e options if further meshes are\n"
	  "being generated, in order to avoid conflicts in GMSH indexing.\n\n"
	  ) ;
  
  fprintf(f,
	  "Options:\n\n"
	  "  -h print this message and exit\n"
	  "  -d # input data file\n"
	  "  -e # element index offset (%d)\n"
	  "  -f # field element index (%d)\n"
	  "  -g # geometry file\n"
	  "  -o # output file (default is stdout)\n"
	  "  -p # point index offset (%d)\n"
	  "  -r # recursion depth for triangle generation (%d)\n"
	  "  -v # name of view in GMSH file\n",
	  offt, field, offp, dmax) ;
	  
  return ;
}

gint main(gint argc, gchar **argv)

{
  gchar *gfile, *dfile, *ofile, ch, *view ;
  nbi_surface_t *s ;
  FILE *input, *output ;
  gint np, fstr, dmax, Nk, xistr, ni, fistr, npmax, ntmax ;
  gint ntri, ne, nd, ppe, field, *tri, tstr, offp, offt ;
  NBI_REAL *K, *xi, *fi, *f ;

  progname = g_strdup(g_path_get_basename(argv[0])) ;

  dmax = 2 ; xistr = 3 ;
  fi = NULL ; fistr = 0 ; fstr = 2 ;
  offp = 0 ; offt = 0 ;

  /*linear output elements, 3 nodes per element*/
  ppe = 3 ;
  
  input = stdin ; output = stdout ;
  gfile = NULL ; dfile = NULL ; ofile = NULL ;
  view = NULL ;
  
  field = 0 ;

  while ( (ch = getopt(argc, argv, "hd:e:f:g:o:p:r:v:")) != EOF ) {
    switch ( ch ) {
    default: g_assert_not_reached() ; break ;
    case 'h':
      print_help_text(stderr, offt, field, offp, dmax) ;
      return 0 ;
      break ;
    case 'd': dfile = g_strdup(optarg) ; break ;
    case 'e': offt = atoi(optarg) ; break ;
    case 'f': field = atoi(optarg) ; break ;
    case 'g': gfile = g_strdup(optarg) ; break ;
    case 'o': ofile = g_strdup(optarg) ; break ;
    case 'p': offp = atoi(optarg) ; break ;
    case 'r': dmax = atoi(optarg) ; break ;
    case 'v': view = g_strdup(optarg) ; break ;
    }
  }

  if ( gfile != NULL ) {
    input = fopen(gfile, "r") ;
    if ( input == NULL ) {
      fprintf(stderr, "%s: cannot open geometry file %s\n",
	      progname, gfile) ;
      exit(1) ;
    }
  }

  s = nbi_surface_read(input) ;

  if ( gfile != NULL ) fclose(input) ;

  if ( dfile == NULL ) {
    f  = (NBI_REAL *)g_malloc0(sizeof(NBI_REAL)) ; fstr = 0 ;
  } else {  
    input = fopen(dfile, "r") ;
    if ( input == NULL ) {
      fprintf(stderr, "%s: cannot open data file %s\n",
	      progname, dfile) ;
      exit(1) ;
    }
    
    f = nbi_data_read(input, &nd, &fstr) ;
    if ( nd < nbi_surface_node_number(s) ) {
      fprintf(stderr,
	      "%s: not enough data points (%d) for surface (%d nodes)\n",
	      progname, nd, nbi_surface_node_number(s)) ;
      exit(1) ;
    }
    fclose(input) ;    

    if ( field >= fstr ) {
      fprintf(stderr,
	      "%s: data file has %d fields, cannot extract field %d\n",
	      progname, fstr, field) ;
      exit(1) ;
    }
  }
  
  /*size workspaces: maximum number of triangles per patch*/
  ntri = 2 << (2*dmax) ;

  fistr = fstr ;
  npmax = nbi_surface_patch_number(s)*ntri*ppe ;
  xi = (NBI_REAL *)g_malloc0(npmax*xistr*sizeof(NBI_REAL)) ;
  tstr = 3 ;
  ntmax = nbi_surface_patch_number(s)*ntri ;
  tri = (gint *)g_malloc0(ntmax*tstr*sizeof(gint)) ;
  if ( dfile != NULL ) {
    fi = (NBI_REAL *)g_malloc0(nbi_surface_patch_number(s)*ntri*fistr*ppe*
			       sizeof(NBI_REAL)) ;
  } else {
    fi = (NBI_REAL *)g_malloc0(sizeof(NBI_REAL)) ;
  }

  np = nbi_surface_patch_node(s, 1) - nbi_surface_patch_node(s, 0) ;
  nbi_element_interp_matrix(np, &K, &Nk) ;

  nbi_mesh_triangulate(s, dmax, K, Nk,
		       xi, xistr, npmax, tri, tstr, ntmax,
		       &(f[field]), fstr, fi, fistr,
		       &ni, &ne) ;
  
  fprintf(stderr, "%d nodes, %d elements generated\n", ni, ne) ;

  fprintf(stderr, "final point: %d\n", offp+ni) ;
  fprintf(stderr, "final element: %d\n", offt+ne) ;

  if ( ofile != NULL ) {
    output = fopen(ofile, "w") ;
    if ( output == NULL ) {
      fprintf(stderr, "%s: cannot open file %s, writing to stdout\n",
	      progname, ofile) ;
    }
  }
  
  nbi_mesh_export_gmsh(output, view,
		       xi, xistr, ni, offp,
		       tri, tstr, ne, offt, fi, fistr) ;

  if ( output != stdout) fclose(output) ;

  return 0 ;
}
