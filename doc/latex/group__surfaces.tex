\doxysection{Surfaces}
\label{group__surfaces}\index{Surfaces@{Surfaces}}


Generating, discretizing and manipulating NBI surfaces.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$ \textbf{ nbi\+\_\+surface\+\_\+alloc} (gint nnmax, gint npmax)
\begin{DoxyCompactList}\small\item\em allocate an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} \end{DoxyCompactList}\item 
gint \textbf{ nbi\+\_\+surface\+\_\+write} (\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$s, FILE $\ast$f)
\begin{DoxyCompactList}\small\item\em write an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} to file \end{DoxyCompactList}\item 
\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$ \textbf{ nbi\+\_\+surface\+\_\+read} (FILE $\ast$f)
\begin{DoxyCompactList}\small\item\em allocate and read an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} from file \end{DoxyCompactList}\item 
gint \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+centroid} (gdouble $\ast$x, gint xstr, gdouble $\ast$w, gint wstr, gint nx, gdouble $\ast$c)
\begin{DoxyCompactList}\small\item\em estimate centroid of surface patch \end{DoxyCompactList}\item 
gdouble \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+radius} (gdouble $\ast$x, gint xstr, gint nx, gdouble $\ast$c)
\begin{DoxyCompactList}\small\item\em estimate radius of circumsphere of surface patch \end{DoxyCompactList}\item 
gint \textbf{ nbi\+\_\+patch\+\_\+neighbours} (gdouble $\ast$c, gdouble r, gdouble $\ast$x, gint xstr, gint nx, gint n0, gint n1, gint $\ast$nbrs, gint $\ast$nnbrs, gint nnmax)
\begin{DoxyCompactList}\small\item\em identify neighbour nodes of surface patch \end{DoxyCompactList}\item 
gint \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+neighbours} (\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$s, gint p, gdouble r, gint $\ast$nbrs, gint $\ast$nnbrs, gint nnmax)
\begin{DoxyCompactList}\small\item\em identify neighbours of a surface patch \end{DoxyCompactList}\item 
gint \textbf{ nbi\+\_\+element\+\_\+interp\+\_\+matrix} (gint ns, gdouble $\ast$$\ast$K, gint $\ast$Nk)
\begin{DoxyCompactList}\small\item\em Koornwinder interpolation matrix for surface patch. \end{DoxyCompactList}\item 
gdouble $\ast$ \textbf{ nbi\+\_\+patch\+\_\+upsample\+\_\+matrix} (gint ns, gint nu)
\begin{DoxyCompactList}\small\item\em matrix for upsampling patch nodes to quadrature nodes \end{DoxyCompactList}\item 
gint \textbf{ nbi\+\_\+surface\+\_\+set\+\_\+patch\+\_\+data} (\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$s)
\begin{DoxyCompactList}\small\item\em set basic data (centroid and radius) for each patch of a surface. \end{DoxyCompactList}\item 
gint \textbf{ nbi\+\_\+geometry\+\_\+sphere} (\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$s, gdouble r, gint nth, gint nph, gint nq)
\item 
gint \textbf{ nbi\+\_\+geometry\+\_\+ellipsoid} (\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$s, gdouble a, gdouble b, gdouble c, gint nth, gint nph, gint nq)
\item 
gint \textbf{ nbi\+\_\+geometry\+\_\+sphere\+\_\+ico} (\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$s, gdouble r, gint nr, gint nq)
\item 
gint \textbf{ nbi\+\_\+geometry\+\_\+ellipsoid\+\_\+ico} (\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$s, gdouble a, gdouble b, gdouble c, gint nr, gint nq)
\item 
gint \textbf{ nbi\+\_\+geometry\+\_\+grid} (\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$s, gdouble smin, gdouble smax, gint ns, gdouble tmin, gdouble tmax, gint nt, gint nq)
\item 
\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$ \textbf{ nbi\+\_\+gmsh\+\_\+mesh} (gchar $\ast$file, gint nq)
\end{DoxyCompactItemize}
\begin{DoxyCompactItemize}
\item 
typedef \textbf{ nbi\+\_\+surface\+\_\+t}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Generating, discretizing and manipulating NBI surfaces. 

NBI represents surfaces as triangular patches which are mapped using Koornwinder orthogonal polynomials, giving a high order representation of the surface and of the potential on it. Surface points are placed at the nodes of high order quadrature rules for the unit triangle, and interpolation of surface quantities, including position, is performed using the Koornwinder polynomials.

A surface patch takes two discretization parameters. The first is the number of nodes on the patch. These are the points where the solution will be found when the problem is solved subject to a given set of boundary conditions. The second parameter is the number of upsampled nodes. In order to evaluate the surface integrals in the problem, the estimated solution is interpolated, or upsampled, onto a set of nodes on each patch, giving a more refined discretization for evaluation of the potential integrals. The number of upsampled nodes should be at least equal to the number of nodes in the patch discretization.

Surfaces can be generated using the built-\/in geometries in NBI (a list is available using the {\ttfamily -\/G} option of {\ttfamily nbi-\/surface}); a GMSH {\ttfamily }.geo file; or an {\ttfamily AGG} file {\texttt{ https\+://github.\+com/mjcarley/agg/}} which uses the geometric representation methods of Kulfan, {\texttt{ https\+://www.\+brendakulfan.\+com/research}}

Built-\/in geometries are quite simple but are sufficient for testing of code and checking the toolchain. There are also grid geometries which are not intended for calculation but are suitable for visualising the potential field around surfaces after a problem has been solved. 

\doxysubsection{Function Documentation}
\mbox{\label{group__surfaces_ga7b45ed83a49ee86f2524ac945ae182b2}} 
\index{Surfaces@{Surfaces}!nbi\_element\_interp\_matrix@{nbi\_element\_interp\_matrix}}
\index{nbi\_element\_interp\_matrix@{nbi\_element\_interp\_matrix}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_element\_interp\_matrix()}
{\footnotesize\ttfamily gint nbi\+\_\+element\+\_\+interp\+\_\+matrix (\begin{DoxyParamCaption}\item[{gint}]{ns,  }\item[{gdouble $\ast$$\ast$}]{K,  }\item[{gint $\ast$}]{Nk }\end{DoxyParamCaption})}



Koornwinder interpolation matrix for surface patch. 


\begin{DoxyParams}{Parameters}
{\em ns} & number of interpolation nodes on patch; \\
\hline
{\em K} & on exit, pointer to interpolation matrix for patch; \\
\hline
{\em Nk} & on exit, maximum order of Koornwinder polynomial in interpolation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}


Referenced by \textbf{ nbi\+\_\+patch\+\_\+upsample\+\_\+matrix()}.

\mbox{\label{group__surfaces_gab8947234c5eab69c2fba9a34dc0cbc07}} 
\index{Surfaces@{Surfaces}!nbi\_geometry\_ellipsoid@{nbi\_geometry\_ellipsoid}}
\index{nbi\_geometry\_ellipsoid@{nbi\_geometry\_ellipsoid}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_geometry\_ellipsoid()}
{\footnotesize\ttfamily gint nbi\+\_\+geometry\+\_\+ellipsoid (\begin{DoxyParamCaption}\item[{\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$}]{s,  }\item[{gdouble}]{a,  }\item[{gdouble}]{b,  }\item[{gdouble}]{c,  }\item[{gint}]{nth,  }\item[{gint}]{nph,  }\item[{gint}]{nq }\end{DoxyParamCaption})}

Generate an ellipsoidal surface


\begin{DoxyParams}{Parameters}
{\em s} & surface to which patches are to be added; \\
\hline
{\em a} & ellipsoid length on $x$ axis; \\
\hline
{\em b} & ellipsoid length on $y$ axis; \\
\hline
{\em c} & ellipsoid length on $z$ axis; \\
\hline
{\em nth} & number of patches in azimuth $\theta$; \\
\hline
{\em nph} & number of patches in elevation $\phi$; \\
\hline
{\em nq} & number of quadrature points per patch.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\mbox{\label{group__surfaces_ga868a1ac59c5ea67aeba5ba039d4c3721}} 
\index{Surfaces@{Surfaces}!nbi\_geometry\_ellipsoid\_ico@{nbi\_geometry\_ellipsoid\_ico}}
\index{nbi\_geometry\_ellipsoid\_ico@{nbi\_geometry\_ellipsoid\_ico}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_geometry\_ellipsoid\_ico()}
{\footnotesize\ttfamily gint nbi\+\_\+geometry\+\_\+ellipsoid\+\_\+ico (\begin{DoxyParamCaption}\item[{\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$}]{s,  }\item[{gdouble}]{a,  }\item[{gdouble}]{b,  }\item[{gdouble}]{c,  }\item[{gint}]{nr,  }\item[{gint}]{nq }\end{DoxyParamCaption})}

Generate an ellipsoidal surface by recursive subvision of a deformed icosahedron


\begin{DoxyParams}{Parameters}
{\em s} & surface to which patches are to be added; \\
\hline
{\em a} & ellipsoid length on $x$ axis; \\
\hline
{\em b} & ellipsoid length on $y$ axis; \\
\hline
{\em c} & ellipsoid length on $z$ axis; \\
\hline
{\em nr} & number of subdivisions; \\
\hline
{\em nq} & number of quadrature points per patch.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\mbox{\label{group__surfaces_gac1dd6cb3d6366bd691de59cf608f0e92}} 
\index{Surfaces@{Surfaces}!nbi\_geometry\_grid@{nbi\_geometry\_grid}}
\index{nbi\_geometry\_grid@{nbi\_geometry\_grid}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_geometry\_grid()}
{\footnotesize\ttfamily gint nbi\+\_\+geometry\+\_\+grid (\begin{DoxyParamCaption}\item[{\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$}]{s,  }\item[{gdouble}]{smin,  }\item[{gdouble}]{smax,  }\item[{gint}]{ns,  }\item[{gdouble}]{tmin,  }\item[{gdouble}]{tmax,  }\item[{gint}]{nt,  }\item[{gint}]{nq }\end{DoxyParamCaption})}

Generate a regular grid in plane $z=0$ which can be transformed and used for visualisation. Nodes are interpolated between $(s_{\min},t_{\min},0)$ and $(s_{\max},t_{\max},0)$


\begin{DoxyParams}{Parameters}
{\em s} & surface to add patches to; \\
\hline
{\em smin} & coordinate of lower left corner of grid; \\
\hline
{\em smax} & coordinate of upper right corner of grid; \\
\hline
{\em ns} & number of nodes in $s$. \\
\hline
{\em tmin} & coordinate of lower left corner of grid; \\
\hline
{\em tmax} & coordinate of upper right corner of grid; \\
\hline
{\em nt} & number of nodes in $t$. \\
\hline
{\em nq} & number of quadrature nodes per patch on {\itshape s}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on succes. 
\end{DoxyReturn}
\mbox{\label{group__surfaces_ga4c31fb52e0ffe2f03eef01dc87b68b78}} 
\index{Surfaces@{Surfaces}!nbi\_geometry\_sphere@{nbi\_geometry\_sphere}}
\index{nbi\_geometry\_sphere@{nbi\_geometry\_sphere}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_geometry\_sphere()}
{\footnotesize\ttfamily gint nbi\+\_\+geometry\+\_\+sphere (\begin{DoxyParamCaption}\item[{\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$}]{s,  }\item[{gdouble}]{r,  }\item[{gint}]{nth,  }\item[{gint}]{nph,  }\item[{gint}]{nq }\end{DoxyParamCaption})}

Generate a spherical surface


\begin{DoxyParams}{Parameters}
{\em s} & surface to which sphere patches are to be added; \\
\hline
{\em r} & radius of sphere; \\
\hline
{\em nth} & number of patches in azimuth $\theta$; \\
\hline
{\em nph} & number of patches in elevation $\phi$; \\
\hline
{\em nq} & number of quadrature points per patch.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\mbox{\label{group__surfaces_gaa2f2fa13ec9deaaa268df42ad2e18652}} 
\index{Surfaces@{Surfaces}!nbi\_geometry\_sphere\_ico@{nbi\_geometry\_sphere\_ico}}
\index{nbi\_geometry\_sphere\_ico@{nbi\_geometry\_sphere\_ico}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_geometry\_sphere\_ico()}
{\footnotesize\ttfamily gint nbi\+\_\+geometry\+\_\+sphere\+\_\+ico (\begin{DoxyParamCaption}\item[{\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$}]{s,  }\item[{gdouble}]{r,  }\item[{gint}]{nr,  }\item[{gint}]{nq }\end{DoxyParamCaption})}

Generate a spherical surface by recursive subdivision of an icosahedron


\begin{DoxyParams}{Parameters}
{\em s} & surface to which sphere patches are to be added; \\
\hline
{\em r} & radius of sphere; \\
\hline
{\em nr} & number of subdivisions; \\
\hline
{\em nq} & number of quadrature points per patch.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\mbox{\label{group__surfaces_ga5846326971e9c4dcf07a9f8a163ce281}} 
\index{Surfaces@{Surfaces}!nbi\_gmsh\_mesh@{nbi\_gmsh\_mesh}}
\index{nbi\_gmsh\_mesh@{nbi\_gmsh\_mesh}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_gmsh\_mesh()}
{\footnotesize\ttfamily \textbf{ nbi\+\_\+surface\+\_\+t} $\ast$ nbi\+\_\+gmsh\+\_\+mesh (\begin{DoxyParamCaption}\item[{gchar $\ast$}]{file,  }\item[{gint}]{nq }\end{DoxyParamCaption})}

Generate an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} from a GMSH .geo file (experimental, but has been reliable up to now)


\begin{DoxyParams}{Parameters}
{\em file} & name of GMSH file; \\
\hline
{\em nq} & number of quadrature points per patch.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to newly allocated \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} containing surface generated from {\itshape file}. 
\end{DoxyReturn}


References \textbf{ nbi\+\_\+surface\+\_\+alloc()}, and \textbf{ nbi\+\_\+surface\+\_\+t}.

\mbox{\label{group__surfaces_ga5e02aeb6ff57f50d45bcd73c14807ca9}} 
\index{Surfaces@{Surfaces}!nbi\_patch\_neighbours@{nbi\_patch\_neighbours}}
\index{nbi\_patch\_neighbours@{nbi\_patch\_neighbours}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_patch\_neighbours()}
{\footnotesize\ttfamily gint nbi\+\_\+patch\+\_\+neighbours (\begin{DoxyParamCaption}\item[{gdouble $\ast$}]{c,  }\item[{gdouble}]{r,  }\item[{gdouble $\ast$}]{x,  }\item[{gint}]{xstr,  }\item[{gint}]{nx,  }\item[{gint}]{n0,  }\item[{gint}]{n1,  }\item[{gint $\ast$}]{nbrs,  }\item[{gint $\ast$}]{nnbrs,  }\item[{gint}]{nnmax }\end{DoxyParamCaption})}



identify neighbour nodes of surface patch 


\begin{DoxyParams}{Parameters}
{\em c} & centroid; \\
\hline
{\em r} & radius of neighbourhood; \\
\hline
{\em x} & list of candidate neighbour nodes; \\
\hline
{\em xstr} & stride from first component of one node to first component of next; \\
\hline
{\em nx} & number of candidate neighbour nodes; \\
\hline
{\em n0} & first entry in {\itshape x} to check; \\
\hline
{\em n1} & last entry in {\itshape x} to check; \\
\hline
{\em nbrs} & on exit contains indices of nodes lying within distance {\itshape r} of {\itshape c}; \\
\hline
{\em nnbrs} & on exit contains number of nodes in {\itshape nbrs}; \\
\hline
{\em nnmax} & maximum number of neighbours to be inserted in {\itshape nbrs}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\mbox{\label{group__surfaces_ga769eecc91ebe23607b5d6771888033cc}} 
\index{Surfaces@{Surfaces}!nbi\_patch\_upsample\_matrix@{nbi\_patch\_upsample\_matrix}}
\index{nbi\_patch\_upsample\_matrix@{nbi\_patch\_upsample\_matrix}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_patch\_upsample\_matrix()}
{\footnotesize\ttfamily gdouble $\ast$ nbi\+\_\+patch\+\_\+upsample\+\_\+matrix (\begin{DoxyParamCaption}\item[{gint}]{ns,  }\item[{gint}]{nu }\end{DoxyParamCaption})}



matrix for upsampling patch nodes to quadrature nodes 


\begin{DoxyParams}{Parameters}
{\em ns} & number of patch nodes (must match an available quadrature rule); \\
\hline
{\em nu} & number of upsampled nodes (must match an available quadrature rule).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to upsampling matrix. 
\end{DoxyReturn}


References \textbf{ nbi\+\_\+element\+\_\+interp\+\_\+matrix()}.

\mbox{\label{group__surfaces_ga048335822ea13156e6e0b8873520839c}} 
\index{Surfaces@{Surfaces}!nbi\_surface\_alloc@{nbi\_surface\_alloc}}
\index{nbi\_surface\_alloc@{nbi\_surface\_alloc}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_surface\_alloc()}
{\footnotesize\ttfamily \textbf{ nbi\+\_\+surface\+\_\+t} $\ast$ nbi\+\_\+surface\+\_\+alloc (\begin{DoxyParamCaption}\item[{gint}]{nnmax,  }\item[{gint}]{npmax }\end{DoxyParamCaption})}



allocate an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} 


\begin{DoxyParams}{Parameters}
{\em nnmax} & maximum number of nodes in surface; \\
\hline
{\em npmax} & maximum number of patches in surface.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to newly allocated \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} 
\end{DoxyReturn}


References \textbf{ nbi\+\_\+surface\+\_\+node\+\_\+number}, \textbf{ nbi\+\_\+surface\+\_\+node\+\_\+number\+\_\+max}, \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+number}, \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+number\+\_\+max}, and \textbf{ nbi\+\_\+surface\+\_\+t}.



Referenced by \textbf{ nbi\+\_\+gmsh\+\_\+mesh()}.

\mbox{\label{group__surfaces_ga5a4b12620fa8aeb55d8bebbcad0846fa}} 
\index{Surfaces@{Surfaces}!nbi\_surface\_patch\_centroid@{nbi\_surface\_patch\_centroid}}
\index{nbi\_surface\_patch\_centroid@{nbi\_surface\_patch\_centroid}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_surface\_patch\_centroid()}
{\footnotesize\ttfamily gint nbi\+\_\+surface\+\_\+patch\+\_\+centroid (\begin{DoxyParamCaption}\item[{gdouble $\ast$}]{x,  }\item[{gint}]{xstr,  }\item[{gdouble $\ast$}]{w,  }\item[{gint}]{wstr,  }\item[{gint}]{nx,  }\item[{gdouble $\ast$}]{c }\end{DoxyParamCaption})}



estimate centroid of surface patch 


\begin{DoxyParams}{Parameters}
{\em x} & coordinates of patch nodes; \\
\hline
{\em xstr} & stride from first component of one to first component of next; \\
\hline
{\em w} & patch quadrature weights; \\
\hline
{\em wstr} & quadrature weight stride; \\
\hline
{\em nx} & number of nodes; \\
\hline
{\em c} & on exit contains coordinates of centroid.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}


Referenced by \textbf{ nbi\+\_\+surface\+\_\+set\+\_\+patch\+\_\+data()}.

\mbox{\label{group__surfaces_ga8d4a8b0201718144afae6d098ad791e3}} 
\index{Surfaces@{Surfaces}!nbi\_surface\_patch\_neighbours@{nbi\_surface\_patch\_neighbours}}
\index{nbi\_surface\_patch\_neighbours@{nbi\_surface\_patch\_neighbours}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_surface\_patch\_neighbours()}
{\footnotesize\ttfamily gint nbi\+\_\+surface\+\_\+patch\+\_\+neighbours (\begin{DoxyParamCaption}\item[{\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$}]{s,  }\item[{gint}]{p,  }\item[{gdouble}]{r,  }\item[{gint $\ast$}]{nbrs,  }\item[{gint $\ast$}]{nnbrs,  }\item[{gint}]{nnmax }\end{DoxyParamCaption})}



identify neighbours of a surface patch 


\begin{DoxyParams}{Parameters}
{\em s} & an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c}; \\
\hline
{\em p} & index of patch whose neighbours are to be found; \\
\hline
{\em r} & radius of neighbourhood; \\
\hline
{\em nbrs} & on exit contains indices of nodes of {\itshape s} lying with distance {\itshape r} of centroid of patch {\itshape p} of {\itshape s}; \\
\hline
{\em nnbrs} & on exit contains number of entries in {\itshape nbrs}; \\
\hline
{\em nnmax} & limit on number of entries in {\itshape nbrs}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\mbox{\label{group__surfaces_gaf28e20127c1a4d932c6d9d98439d0c56}} 
\index{Surfaces@{Surfaces}!nbi\_surface\_patch\_radius@{nbi\_surface\_patch\_radius}}
\index{nbi\_surface\_patch\_radius@{nbi\_surface\_patch\_radius}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_surface\_patch\_radius()}
{\footnotesize\ttfamily gdouble nbi\+\_\+surface\+\_\+patch\+\_\+radius (\begin{DoxyParamCaption}\item[{gdouble $\ast$}]{x,  }\item[{gint}]{xstr,  }\item[{gint}]{nx,  }\item[{gdouble $\ast$}]{c }\end{DoxyParamCaption})}



estimate radius of circumsphere of surface patch 


\begin{DoxyParams}{Parameters}
{\em x} & coordinates of patch nodes; \\
\hline
{\em xstr} & stride from first component of one node to first component of next; \\
\hline
{\em nx} & number of patch nodes; \\
\hline
{\em c} & centroid of patch (from nbi\+\_\+surface\+\_\+patch\+\_\+centroid)).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
patch radius 
\end{DoxyReturn}
\mbox{\label{group__surfaces_ga1e35bb2cabf96f7e4063962f94816222}} 
\index{Surfaces@{Surfaces}!nbi\_surface\_read@{nbi\_surface\_read}}
\index{nbi\_surface\_read@{nbi\_surface\_read}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_surface\_read()}
{\footnotesize\ttfamily \textbf{ nbi\+\_\+surface\+\_\+t} $\ast$ nbi\+\_\+surface\+\_\+read (\begin{DoxyParamCaption}\item[{FILE $\ast$}]{f }\end{DoxyParamCaption})}



allocate and read an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} from file 


\begin{DoxyParams}{Parameters}
{\em f} & input file stream.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to newly allocated surface, read from file 
\end{DoxyReturn}


References \textbf{ nbi\+\_\+surface\+\_\+t}.

\mbox{\label{group__surfaces_ga12135d339936f354de509a6fcb4e19b2}} 
\index{Surfaces@{Surfaces}!nbi\_surface\_set\_patch\_data@{nbi\_surface\_set\_patch\_data}}
\index{nbi\_surface\_set\_patch\_data@{nbi\_surface\_set\_patch\_data}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_surface\_set\_patch\_data()}
{\footnotesize\ttfamily gint nbi\+\_\+surface\+\_\+set\+\_\+patch\+\_\+data (\begin{DoxyParamCaption}\item[{\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$}]{s }\end{DoxyParamCaption})}



set basic data (centroid and radius) for each patch of a surface. 


\begin{DoxyParams}{Parameters}
{\em s} & an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} whose data are to be set.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 
\end{DoxyReturn}


References \textbf{ nbi\+\_\+surface\+\_\+node}, \textbf{ nbi\+\_\+surface\+\_\+node\+\_\+weight}, \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+centre}, \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+centroid()}, \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+node}, \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+node\+\_\+number}, \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+number}, and \textbf{ nbi\+\_\+surface\+\_\+patch\+\_\+sphere\+\_\+radius}.

\mbox{\label{group__surfaces_ga2e1a8a248496955944f7504696c957a6}} 
\index{Surfaces@{Surfaces}!nbi\_surface\_write@{nbi\_surface\_write}}
\index{nbi\_surface\_write@{nbi\_surface\_write}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_surface\_write()}
{\footnotesize\ttfamily gint nbi\+\_\+surface\+\_\+write (\begin{DoxyParamCaption}\item[{\textbf{ nbi\+\_\+surface\+\_\+t} $\ast$}]{s,  }\item[{FILE $\ast$}]{f }\end{DoxyParamCaption})}



write an \doxyref{nbi\+\_\+surface\+\_\+t}{p.}{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c} to file 


\begin{DoxyParams}{Parameters}
{\em s} & surface to write to file \\
\hline
{\em f} & output file stream\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success 
\end{DoxyReturn}


\doxysubsection{Variable Documentation}
\mbox{\label{group__surfaces_gaf7311c75f0c2eed96f648ce53d435c8c}} 
\index{Surfaces@{Surfaces}!nbi\_surface\_t@{nbi\_surface\_t}}
\index{nbi\_surface\_t@{nbi\_surface\_t}!Surfaces@{Surfaces}}
\doxysubsubsection{nbi\_surface\_t}
{\footnotesize\ttfamily nbi\+\_\+surface\+\_\+t}

Basic data type for NBI surfaces, including element and quadrature information 

Referenced by \textbf{ nbi\+\_\+gmsh\+\_\+mesh()}, \textbf{ nbi\+\_\+surface\+\_\+alloc()}, and \textbf{ nbi\+\_\+surface\+\_\+read()}.

